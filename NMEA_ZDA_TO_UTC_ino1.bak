// GNZDA_to_UTC, à partir du message NMEA "$GNZDA,Time,Date" envoyer le message "$UTC,Date,Timee" pour simuler ce message non standard d'Applanix "tm".
//
// Promoteur   : Raphaël Mabit 
// Auteur      : Bruno Dionne 2023-06-04
// Motivation  : Un data loggeur commercial avec 8 ports série, refuse de fonctionner tant que le message GPS non standard "$UTC,<date>,<time>" n'est pas reçu à intervalle régulier.
//
// Suggestion d'interconnexion *****
//
// U-Blox ZED-F9R <--uart1--> Artemis Thing PLus   ------------------> DataLogger.
// U-Blox ZED-F9R <--QWIIC--> Artemis Thing PLus  
// U-Blox ZED-F9R <- uart2--> Serial to Bluetooh  <------------------> Ordinateur, Tablette ou Mobile
//
// GPS TX UART1  ----> RX Serial1 (Artemis thing plus) TX Serial1 ---> RX DataLogger.
//
// TX/RX UART2    <---> Module Bluetooth 4.0 SPP     <---> SPP Téléphone/Tablette.
// i2c QWIIC      <---> i2c QWIIC Artemis thing plus <---> Librairie "SparkFun_u-blox_GNSS_v3"
//
// Artemis thing plus particulatités ***** 
//
// Serial  est le port série UART via le port USB-C.
// Serial1 est l'autre port série UART via les broches TX et RX.
// Module Bluetooth BLE intégré pour envoyer ou recevoir des données de surveillance, des commandes de contrôle ou autres à une tablette ou un téléphone intelligent.
// Ne pas connecter ni la broche 3.3V ni la broche GND du connecteur QWIIC i2c au ZED-F9R ou à n'importe quoi connecté au ZED-F9R. Cela cause des délais inexplicables dans le traitmenet des données UART.
//
// Fonctionnement général :
//     Lire les messages NMEA du GPS qui arrivent en bloc juste après le signal PPS.
//     On note le temps d'arrivée du premier caractère '$' reçus pour estimé au mieux le déalais avec le signal PPS.
//     Chaque caratère reçu est immédiatement renvoyé sans traitement vers le data loggeur. 
//     Le message NMEA en cours de réception est stocké en mémoire temporairement pour traitement futur.
//     Le dernier message reçu est $GNZDA, avec l'heure et la date UTC.
//     On note le temps d'arrivée du dernier caractère reçu pour estime le temps de transit du bloc de message NMEA.
//     À partir du message $GNZDA stocké en mémoire, on contruit le nouveau message $UTC,Date,Heure au format Applanix.
//     On incrémente l'heure UTC du temps de transit du bloc de messages et délais PPS/Bloc messages NMEA, pour estimé au plus proche (± 0.5 milliseconde) l'heure UTC réelle de la transmission du message $UTC
//        Il est possible dans le code d'ajouter un offset supplémentaire à l'heure UTC, pour tenir compte du temps de traitement du message UTC par le Data Loggeur.
//
//     Un bloc de message NMEA se traite en 45 millisecondes en moyenne, il est donc possible de supporter le refresh maximal de 10 Hz du ZED-F9R.
//     Pour un total de 450 millesecondes de traitement entre chaque PPS.
//     Ce qui laisse un marge de manoeuvre pour ajouter d'autres fonctions personnalisées.
//
// Développement furtur :
//     Synchroniser l'horloge en temp réel RTC du Artemis thing plus avec le temps UTC aux fins de validations et vérification (GPS time anti spoofing).
//     Ajouter une fonction au bouton usager du Artemis Thing Plus pour des fonctionnalités supplémentaires. 
//     Ajouter une interruption pour capturer des alarmes de l'horloge en temps réeal RTC du Artémis Thing PLus pour des fonctionnalités supplémentaires.
//     Ajouter des sondes externes pour supporter plus de type de messages NMEA.
//     
//
// ***** Include  *****
//
//
#include <Arduino.h>          // Librairies, variables et constantes standards Arduino.
#include <SPI.h>              // used for SPI communication.
#include <Wire.h>             // Used for serial communication over USB //Needed for I2C to GNSS.
//#include "RTC.h"            // Real time clock. The RTC library included with the Arduino_Apollo3 core. Pas utilisé pour le moment.
//#include "WDT.h"              // Watchdog library
//#include <ArduinoBLE.h>     // Module intégré Bluetooth BLE du Artemis thing plus. Pas utiliser pour le moment.
//
//
// ***** U-blox Sparkfun librairie en option *****
//
//
//#include <SparkFun_u-blox_GNSS_v3.h> //http://librarymanager/All#SparkFun_u-blox_GNSS_v3
//SFE_UBLOX_GNSS myGNSS;
//
//#define myWire Wire1 // Connect using the Wire1 port. Change this if required
//#define gnssAddress 0x42 // The default I2C address for u-blox modules is 0x42. Change this if required
//
//
// ***** Define *****
//
//
// ***** Constant *****
//
//
// Habituellement les SBC Arduino définissent 'LED_BUILTIN'
// Ce symbole est associé à la broche pin_size_t qui est la LED embarquée.
//
const pin_size_t ledPinNumber = LED_BUILTIN;  //LED par son numéro de broche
//
// Mbed boards use a PinName called LED1 to indicate the built-in LED
//
const PinName ledPinName = LED1;  // By name
//
const int ppsIntPin        =  5;   // Numéro de la broche pour l'Interruption  de détection du signal PPS
const int spiChipSelectPin =  9;   // Numéro de la broche pour Chip select du port SPI
const int buttonIntPin     = 10;   // Numéro de la broche pour le "user button" 
const int resetPin         =  6;   // Numéro de la broche reliée à la broche RESET du GPS U-BLox ZED-F9R et ou du Artemis thing plus au choix.
const int transmitReadyPin =  7;   // Numéro de broche reliée à la broche TXR du GPS U-BLox ZED-F9R
//
//
// ***** Variable  *****
//
//
// ***** Variable pour les interruption ISR
//
volatile bool alarmISR_         = false; // Cette variable est assignée à true si l'horloge interne du Apollo génère une interruption ex: "alarme".
volatile bool buttonISR_        = false; // Cette variable est assigné à true si on appui sur le "user button".
volatile bool ppsISR_           = false; // Cette variable est assigné à true si le signal PPS en provenance du GPS est détectée.
volatile bool TransmitReadyISR_ = false; // Cette variable est assigné à true si le signal Transmit Ready en provenance du GPS U-BLox ZED-F9R est détectée.
volatile unsigned long horodatePPS = 0; //  test

//
volatile bool watchdogFlag = false; // indicateur Watchdog Timer ISR flag
volatile int watchdogInterrupt = 0; // Compteur Watchdog interrupt counter
//
// ***** autres variables 
//
// ***** Object  *****
//
//
///*********************************************************/
//
//
// ***** Routines *****
//
//
// Routines de gestion des interruptions
//
void ppsISR()                       // Noter le temps d'arrivée du signal PPS.
{
  horodatePPS = millis();
  ppsISR_ = true;
}
//
void ButtonISR()                     // Usage futur de détection du bouton. Ex: Déclencher un traitement si le bouton est poussé par un usager.
{
  buttonISR_ = true;
}
//
//
void TransmitReadyISR()
{
  TransmitReadyISR_ = true; 
  ppsISR_ = true;
}
//
//
//
//extern "C" void am_rtc_isr(void)     // Usage futur de l'horloge en temp réel du Artemis thing plus. Ex: déclenchement d'un traitement par une alarme de l'horloge  ± 4 microsecondes.
//{ 
//  am_hal_rtc_int_clear(AM_HAL_RTC_INT_ALM);    // Effacer RTC alarm interrupt
//  alarmISR_ = true;  
//}
//
//***************************************************************/
// ***** Appelé une fois quand le MCU est alimenté ou reset *****/
//***************************************************************/
//
void setup() { 
  byte tempoByte = 0;
  // La pin ResetPin #? est reliée à la pin RESET du Artemis thing plus ou du GPS.
  // When the application starts up, all pins get pulled LOW. 
  // This would therefore disable Arduino from every running
  // BUT, the trick is: in setup() function, the FIRST thing that happens is we write HIGH to the pin resetPIN
  //digitalWrite(resetPin, HIGH );                                        //Le plus rapidement possible mettre à HIGH la pin reliée à la pin RESET
  //delay(200);                                                         // Enlever le délais de 200 mS il empêche le Artemis thing plus de recevoir le code compilé par Arduino IDE
  //pinMode(resetPin, OUTPUT);                                            // Ensuite en mode OUTPUT
  //digitalWrite(transmitReadyPin, HIGH );                                //Le plus rapidement possible mettre à HIGH la pin reliée à la pin RESET
  //delay(200);                                                        // Enlever le délais de 200 mS il empêche le Artemis thing plus de recevoir le code compilé par Arduino IDE
  //pinMode(transmitReadyPin, OUTPUT);                                   // Ensuite en mode OUTPUT
  //
  Serial.begin(115200);                                                 // Start USB serial communication
  while (!Serial);                                                      // Wait for serial connection to open (only necessary on some boards)  //En commentaire au cas ou le port USB du Artemis thing plus ne serait pas branché à un ordi.
  Serial.print( "INFO, Serial USB=OK" );                                // Confirmation de la disponibilité du port Série USB  "Serial"  
  Serial1.begin(115200);                                                // Port série UART du Artemis thing plus.  "Serial1"
  while (!Serial1);                                                     // Wait for serial connection to open (only necessary on some boards).
  Serial.print( ", Serial1 UART=OK" );                                  // Confirmation de la disponibilité du port Série UART "Serial1"
  // 
  pinMode(LED_BUILTIN, OUTPUT);                                         // Gestion de la LED bleue à OFF.  

  pinMode( ppsIntPin, INPUT );                                          //set the IRQ pin as an input pin. do not use INPUT_PULLUP - the ZED-F9R will pull the pin.
  //attachInterrupt(digitalPinToInterrupt(ppsIntPin), ppsISR, RISING);    // Le ZED-F9R will pull the interrupt pin HIGH when a PPS event is triggered.
  Serial.print(", PPS Interrupt=OK" );                                // Confirmer le mise en place de l'interruption
  pinMode( transmitReadyPin, INPUT );                                          //set the IRQ pin as an input pin. do not use INPUT_PULLUP - the ZED-F9R will pull the pin.
  //attachInterrupt(digitalPinToInterrupt(transmitReadyPin), TransmitReadyISR, RISING);    // Le ZED-F9R will pull the interrupt pin HIGH when a PPS event is triggered.
  //Serial.println(", TransmitReady Interrupt=OK" );                                // Confirmer le mise en place de l'interruption
  //wdt.stop();
    while( Serial1.available()){ tempoByte = Serial1.read();}  // Vider le tampon des caractères reçus du GPS pour un démarrage propre de loop().
  Serial.println(", flush rx");
}
//
//
//******************************************************************************************
// !!!!! Après "setup()", "loop()" est une boucle infinie tant que le MCU est alimenté !!!!!
//******************************************************************************************
//
//
void loop() { // La boucle loop() est trop lente pour des SBC de moins de 16 MHz. Mais le Artemis Thing Plus roule à 48 MHz
  const byte numChars = 255;                      // Size du Buffer de caractères temporaire pour un message NMEA  Débutant par '$' et se terminant par une fin de ligne. 
  static char receivedChars[numChars];            // Buffer de caractères temporaire pour un message NMEA  Débutant par '$' et se terminant par une fin de ligne. 
  byte inByte =0;                                 // Caratère courant
  static char utcDate[9];                         // Extraction de la Date à partir du message $GNZDA avec la virgule    AAAAMMJJ,
  static char utcTime[7];                         // Extrsction de l'heure à partir du message $GNRMC avec le point      HHMMSS.
  static byte indexMsg = 0;                       // Index du tableau des caractères pour le message courant
  static bool debutNMEA = false;               // Détection du caractère '$'
  static bool finNMEA = false;                 // Détection du caractère de fin de ligne \n - 10 
  static bool estArriveZDA = false;
  static unsigned long horodateDebutBlocNMEA = 0;       // Timestamp début des messages pour une seconde donnée PPS, en millisecondes écoulée depuis le dernier powerON ou reset du SBC.
  static unsigned long horodateFinBlocNMEA = 0;         // Timestamp fin   des messages pour une seconde donnée PPS, en millisecondes écoulée depuis le dernier powerON ou reset du SBC.

   unsigned long dureeTransmissionBlocNMEA = 0;        // Durée totale en miliseconde du traitement des messages suivant tout suite un PPS.
  unsigned long decalagePPS_BlocNMEA = 0;              // Delais avant l'arrivée des messages NMEA pour un PPS données ou délais de "Position fix calculation".
  static unsigned long DeltaUTC = 0;              // Correrction du temps UTC de GNZDA pour ajouter le délais PPS-NMEA, le délais de transmission RS-232 et l'imprécision du timer millis()
  static unsigned long overflowDeltaUTC = 0;      // Compter le nombre de dépassement anormalement long de DeltaUTC  (Bug hardware/software introuvable pour le moment)
  //static unsigned long horodatePPS = 0;
  static unsigned long lastEventPPS = 0;          // Utiliser pour calculer le le déaps entre deux PPS
  //
  //  
  if (ppsISR_ == true){                           // Un event PPS est détecté.
    //horodatePPS = millis(); est exécuté dans la procédure d'interruption du PPS.
    horodateFinBlocNMEA = millis();               // Lors du PPS le bloc NMEA est déjà en cours de réception, mais n'est pas nécesssairement arrivé au complet, à cause du PPS la suite suivras seuelement 900 mS plus tard/trop tard (BUG U-Blox).
    Serial.write('~');                            // Marque de debug pour l'arrivé du signal PPS
    digitalWrite(LED_BUILTIN, HIGH);              // Allumer la LED bleue poir indiquer l'arrivé de su signal PPS.
    ppsISR_ = false;                              // indiqué que le traitement PPS est fait.
    Serail1.write('~');
  }//endif ppsISR
  //  
  //
  if( Serial1.available()) {                                 // Caractères disponibles en provenance du GPS ?
    inByte = Serial1.read();                                  // Lire un caractère comme un byte en provenance du GPS ( Serial1 broche RX en provenance du GPS)
    Serial1.write( inByte  );                                 // Écrire ce même caractère vers le data logger         ( Serial1 broche TX à destination du data loggeur)
    //
                  if( horodateDebutBlocNMEA == 0){                // Si un caractère est reçu et horodateDebutBlocNMEA==0 on initiale toutes les variable comme un POWER ON /RESET.

                  horodateDebutBlocNMEA = millis();
                  for (int i = 0; i < 8; i++) {               //Vide la date.
                    utcDate[i] = '0';
                  }  utcDate[8] = ',';
                  for (int i = 0; i < 6; i++) {               //Vide la date.
                    utcTime[i] = '0';
                  }  utcDate[6] = '.';
                }
    //
    if( inByte == '$' ) {                                     // Est-ce un début de message '$' ?
      debutNMEA = true;                                       // Alors début de message alors ajuster le flag de début
      finNMEA   = false;                                      // C'est un début de message alors annule le flag de fin de message
      receivedChars[0] = inByte;                              // Enregistre la caractère courant dans le buffer. Le début de message commence toujours à l'indice zéro du tableau      
      indexMsg = 1;   
    } else if ( inByte == 10 /*|| indexMsg > 87*/ ) {      // Fin message ? Max longueur NMEA = 85, mais U-BLox génère excetionnelement un message NMEA de longueur = 87, et aussi des message vides de longueur variables mais avec un LF à la fin.  
        horodateFinBlocNMEA = millis();
        receivedChars[indexMsg] = inByte;                   // Enregistre la caractère courant dans le buffer, Force à LF au cas ou le message > 82 caractères
        indexMsg++;                                         // incrémente le pointeur du tableau des caractères reçus.
        finNMEA = true;                                     // Fin de message détectée
        //  Serial.print("F,");  
      }                                                   // Ne pas incrémenter indexMsg, ce caratère NULL ne fait pas partie de la chaîne et ne doit pas être transmis.
    else {                                                // Si un message est en cours de détection, accumuler les carractères dans le tableau pour traitement ultérieur
      if( debutNMEA){                                     // N'enregistre aucun caractères s'il n'y a pas un début de détecté. On évite le traitement en milieu de message et les lignes vides.
        receivedChars[indexMsg] = inByte;                 // Enregistre la caractère courant dans le buffer
        indexMsg++;                                        // incrémente l'index tableau  
      }
    }
    digitalWrite(LED_BUILTIN, LOW);               // Éteindre la LED bleue pour indiquer la fin du traitment de remplisssage du tableau
    //
    // Le caractère reçu a été envoyé et traité.
    //     S'il reste des caractères du bloc à recevoir, vous avez entre 2.6 mS et maximum 5.6 mS pour faires des tâches connexes. Sinon il y a risque de perdre des caractères en provenance du GPS (Tampon Serie de 32 à 64 caractères à 155200 bauds)
    //     Si c'est le dernier caratère du bloc vos avez environ 900 mS pavant le prochain PPS pour faire des tâches connexes. Sinon il y a risque de perdre des caractères en provenance du GPS.
    //
    if ( debutNMEA &&  finNMEA ) {  // Le message NMEA courant est complet
      if (receivedChars[0] == '$' && receivedChars[1] == 'G' && receivedChars[2] == 'N' && receivedChars[3] == 'R' && receivedChars[4] == 'M' && receivedChars[5] == 'C' && receivedChars[6] == ',' ) { //Message "$GNRMC," détecté. Extraire l'heure UTC de ce message avant l'arrivé imminente du PPS )(Précède toujours le PPS)
        utcTime[0] = receivedChars[7];    //H
        utcTime[1] = receivedChars[8];    //H
        utcTime[2] = receivedChars[9];   //M
        utcTime[3] = receivedChars[10];   //M
        utcTime[4] = receivedChars[11];   //S
        utcTime[5] = receivedChars[12];   //S
        utcTime[6] = receivedChars[13];   //.
        Serial.write( &utcTime[0], 7); 
        Serial.write ("\r\n");
      }//endif $GNRMC,
      //  
      if (receivedChars[0] == '$' && receivedChars[1] == 'G' && receivedChars[2] == 'N' && receivedChars[3] == 'Z' && receivedChars[4] == 'D' && receivedChars[5] == 'A' && receivedChars[6] == ',' ) { //Message "$GNZDA," peut être entrecouper d'un délais de 900 mS à cause de la dérive du signal PPS (avant ou pendant ou  après le PPS)
        //Ce n'est pas grave si le message "$GNZDA," est entrecoupé d'un délais de 900 mS car on ne garde que la date. 
        //Raphaël ne fait pas de kayak à 20h00 EST car il y a bug extrême ici. Le changement de date est potentiellement retardé d'une seconde à cause de la dérive du PPS dans les messages NMEA :), mais l'heure est toujours bonne.
        utcDate[0] = receivedChars[23];   //A
        utcDate[1] = receivedChars[24];   //A
        utcDate[2] = receivedChars[25];   //A        
        utcDate[3] = receivedChars[26];   //A
        utcDate[4] = receivedChars[20];   //M
        utcDate[5] = receivedChars[21];   //M
        utcDate[6] = receivedChars[17];   //J
        utcDate[7] = receivedChars[18];   //J
        utcDate[8] = receivedChars[27];   //,
        Serial.write( &utcDate[0], 9); 
        Serial.write ("\r\n");
      }//endif $GNZDA,
      debutNMEA = false;           // Message traité on attend un nouveau message
      finNMEA = false;                               // Message traité on attend un nouveau message laisse la fin à true et le debut à false pour indiquer qu'un bloc a été entièrement traité et on est en attente du rpochain PPS
    }//endif debut et fin,
  } else if ( /*horodateFinBlocNMEA + 10UL < millis() &&*/ false ) {//endif Serial.available // else Si après avoir reçu un message NMEA complet, il se passe 10 mS sans recevoir de caractère
    // Full traitement UTC
    //
        Serial1.write( "$UTC,");                          // $UTC,  Nom du message  // Message NMEA "$GNZDA," reçu, il est temps de construire le message "$UTC,"
        Serial1.write( &receivedChars[23], 4);            // $GNZDA Année AAAA
        Serial1.write( &receivedChars[20], 2);            // $GNZDA Mois  MM
        Serial1.write( &receivedChars[17], 3);            // $GNZDA Jour + la virgule     JJ,
        Serial1.write( &receivedChars[7], 7);             // $GNZDA HHMMSS. + le point
        //horodateFinBlocNMEA = millis();                     // Horodatage de la fin du message NMEA coutant et potentiellement la fin bloc de messages NMEA
        //
        dureeTransmissionBlocNMEA =  (unsigned long) (horodateFinBlocNMEA - horodateDebutBlocNMEA); // Temps total de traitement avec une protection contre le rollover 
        decalagePPS_BlocNMEA = (unsigned long) ((( horodateDebutBlocNMEA - horodatePPS )*47UL)/46.875);      // Délais avant l'envoi des messages NMEA par le GPS causé par le temps nécessaire pour le calcul de la position.
        DeltaUTC = (unsigned long) (decalagePPS_BlocNMEA + dureeTransmissionBlocNMEA);
        //                                                        
        if ( DeltaUTC > 999 ){                                  // Bug pour l'instant inexplicable de "900mS" au lieu de "45mS" pour DureeeTransit être >= 900 ms. Regulateur de voltage capricieux ?, attendre 10+ secondes entre les rebranchements de l'alimentation.
          Serial1.write( "335" );                               // on impose une limite maximale fictive à la durée de transit d'une cohorte.
          } else {                                              // On prend pour acquis de la partie fractionnaire des secondes est toujours zéro = "00" à 1 Hz.
              if ( DeltaUTC < 100 ) { Serial1.write( '0'); }    // Format du nombre avec des zéros signaficatifs avant
              if ( DeltaUTC <  10 ) { Serial1.write( '0'); }    // Format du nombre avec des zéros signaficatifs avant
              Serial1.print( DeltaUTC );                        // Différentiel entre le temps réel UTC et le temps de transit GPS->Data Loggeur. 
          }
        Serial1.write( '0');                                   // Ajout d'un zéro à la 4e position après le point comme le message $UTC de l'Applanix  
        Serial1.write("\r\n");                                 // Fin de ligne.  13 - Retour de chariot - Carriage Return - \r et 10 - Nouvelle ligne - Line Feed \n
/*      Serial1.write("$DELTA,PPS_NMEA=" );                         // Nouveau message non standard pour afficher le différentiel UTC et temp de traitements pour information seulement.
        Serial1.print( decalagePPS_BlocNMEA);                       // Le délais causé par le temps de calcul de la position par le GPS après l'envoi du PPS
        Serial1.print(" mS, RXTX= ");                             //
        Serial1.print( dureeTransmissionBlocNMEA);                   // Le délais de réception et de retransmission des messages NMEA d'une même cohorte PPS.
        Serial1.println(" mS");
        Serial1.write("\r\n");                                 // Fin de ligne.  13 - Retour de chariot - Carriage Return - \r et 10 - Nouvelle ligne - Line Feed \n
*/
        Serial.write( "$UTC,");                          // $UTC,  Nom du message     
        Serial.write( &receivedChars[23], 4);            // $GNZDA Année
        Serial.write( &receivedChars[20], 2);            // $GNZDA Mois
        Serial.write( &receivedChars[17], 3);            // $GNZDA Jour + la virgule
        Serial.write( &receivedChars[7], 7);             // $GNZDA HHMMSS + le point
        Serial.write( "00 : "); 

        Serial.print( "PPS= ");                                  // Debuggeur moniteur série USB 
        Serial.print( horodatePPS );                               // Horodatage en milliseondes de l'arrivé du signal PPS
        Serial.print( "\tDebut= ");
        Serial.print( horodateDebutBlocNMEA );                        // Horodatage en milliseondes de l'arrivé du premier caractère '$' des messages NMEA
        Serial.print( "\tFin= ");
        Serial.print( horodateFinBlocNMEA );                          // Horodatage en milliseondes de l'arrivé du dernier caractère des messages NMEA
        Serial.print( "\tDeltaPPS= ");
        Serial.print( (unsigned long)  round((((horodatePPS -  lastEventPPS)*47UL)/46.859)));
        Serial.print( " \tDeltaNMEA= " );
        Serial.print( DeltaUTC );   
        Serial.print( "\tDeltaTX= ");
        Serial.print( (int) dureeTransmissionBlocNMEA );
        Serial.print ( " \toverflowUTC( " );
        Serial.print( overflowDeltaUTC );
        Serial.println ( " )" );
        if ( overflowDeltaUTC == 6UL ){
          //Serial.println ( "RESET GPS..." );
          //digitalWrite(resetPin, LOW);                    // Le board Artemis est resetté, l'éxécution s'arrête ici et reprendra à "void setup()""
          //digitalWrite(resetPin, HIGH);                    // Le board Artemis est resetté, l'éxécution s'arrête ici et reprendra à "void setup()""
          //overflowDeltaUTC--;
        }  
        //if ( overflowDeltaUTC >= 10UL){
          //wdt.start();                                        // Le board Artemis est RESET par le Watchdog timer après   ?? secondes (valeur par défaut de WDT)
          //while(true){}
        //}  
        //if (  DeltaUTC >=  500UL ) {                           // Si le temps de traitement des messages NMEA est trop long c'est notre bug. RESET GPS après 3 overflow. RESET Artemis après 4 overflowle board.  Vérification à chaque PPS
          //overflowDeltaUTC = 2;
          //  Serial1.write( "$ERROR, DeltaUTC >= 500 mS.\r\n" );
          //  Serial.println("$ERROR, DeltaUTC >= 500 mS.");
        //} else { if( overflowDeltaUTC >= 1 ) {overflowDeltaUTC--;}}
        //  
        horodateDebutBlocNMEA = 0;        //$GNZDA, étant le dernier message d'un bloc on prépare les horodateurs pour le prochain bloc.
        horodateFinBlocNMEA = 0;          //$GNZDA, étant le dernier message d'un bloc on prépare les horodateurs pour le prochain bloc.
        lastEventPPS = horodatePPS;       // Pour le caclul de la durée entre deux PPS.

    } //if find bloc NMEA depuis 10 mS
}//end loop
//
//
//
//
// ++++++++++ FIN DU PROGRAMME ++++++++++
//
//
// Note pour la section loop()  *****
//
//
// Ici faire des chose de non-blocante et pas de niaisage.
//
// À 115200 bauds, un caractère est transmis en 86 microsecondes.
//   À 115200 baud entre chaque caractère reçu, Arduino dispose de 86 microsecondes ou 1276 instructions Arduino pour faire d'autre chose.
// Le buffer Serial est de 64 caractères, on estime 32 caractères IN et 32 caractères OUT quand le car le flow des données est relativement symétrique.
//   32 caractères * 86 microsecondes =  2,7 millisecondes de lousse.
//   Ici tous les caractères sont envoyés à mesure de leurs réception, au pif 60 caractères IN et 4 caractères OUT pour le pire cas. Donc un lousse sécuritaire entre 5,34 et 5,69 millisecondes.  
// Quand une série complète de messages est reçue (environ 512 caractères ou 45 millisecondes) il reste environ 955 millisecondes d'attente avant la prochaine série associée au PPS suivant.
//   Durant cette attente pour le prochain PPS c'est à ce moment que le message $UTC est construit de toute pièces à partir du message "$GNZDA,".
//   Le message "$GNZDA," étant le dernier message de la série à être envoyé, c'est pratique pour faire suivre immédiatemewnt par "$UTC" en profitant du temps libre inter message de 956 millisecondes. 
//
// Attention simple guillemet pour le type char et double guillemet pour le type string
//
// Ne pas utiliser les fonctions suivantes car elle sont blocantes, Arduino ne peu faire rien d'autre tant que la fonction n'est pas terminée
//   Serial.parseInt()
//   Serial.parseFloat()
//   Serial.readBytes()
//   Serial.readBytesUntil()
//
// Les MCU Arduino ont généralement très peu de mémoire RAM. La string class cause possiblement des corruption sde mémoire. Voir les alternatives ici avec des fcontions des librairies "C"http://www.cplusplus.com/reference/cstring/
//
// char myChar = 'A';
// char myChar = 65; // Les deux sont équivalent
//
// Opérateurs logiques
//
// and             &&
// and_eq          &=
// bitand          &
// bitor           |
// not             !
// not_eq          !=
// or              ||
// or_eq           |=
// xor             ^
// xor_eq          ^=
//
// La fonction millis() est basé sur un compteur interne au CPU qui divise la frequence du proceessuer par 1024
// Si le CPU a une fréquence 48 MHz ou 48 000 000 de cycle par secondes
// Alors 48 000 000 divisé par 1024 donne 46 875 cycle par secondes
// On as 46 875 divisé par 1000 = 46.875 cycle par millisecondes
// Le compteur est un nombre entier, donc on arrondi à 47 cycle par milliseconde
// le ratio de 46.85 divise par 47 donne 0,9973 
// Donc un tick d'une durée supposé de 1 millisecondes est en réalité 0.9973 milliseconde.
// Donc 1 000 millisecondes multiplié par le ratio 0,9773 et arrondis donne 977 tick de simili millisecondes pour une durée réelle de 1 000 millisecondes.
//
//
// ***** LA VRAI FIN *****